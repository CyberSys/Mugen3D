local utils = require "utils"

local FIELD_DELIMITER = ','
local DOUBLEQUOTE = true
local QUOTECHAR = '"'
local NEWLINE  = '\n'
local CHRRIAGERETURN = '\r'
local char_delimiter = ','
local char_quote = '"'
local char_new_line = '\n'
local char_carriage_return = '\r'

local buff = {
    value = "",
    pos = 0,
    pos_len  = 0,
    pos_char = nil,
}

buff.__index = buff

function buff:new(s)
    local o = setmetatable({}, self)
    o.value = s
	--utf8 bom head
    if o.value:sub(1, 3) == "\239\187\191" then
        o.pos = 4
    else
        o.pos = 1
    end
    o.pos_char = o.value:sub(o.pos, o.pos)
    if     o.pos_char:match("[\000-\127]") then o.pos_len = 1
    elseif o.pos_char:match("[\192-\223]") then o.pos_len = 2
    elseif o.pos_char:match("[\224-\239]") then o.pos_len = 3
    elseif o.pos_char:match("[\240-\247]") then o.pos_len = 4
    else
        error("invalid leading byte, please make sure your csv file is utf8 format")
    end
    return o
end

function buff:character(p)
    local c1 = self.value:sub(p, p)
    local count = 0
    if     c1:match("[\000-\127]") then count = 0
    elseif c1:match("[\192-\223]") then count = 1
    elseif c1:match("[\224-\239]") then count = 2
    elseif c1:match("[\240-\247]") then count = 3
    else 
        error("invalid leading byte, please make sure your csv file is utf8 format")
    end
    return self.value:sub(p, p + count), count + 1    
end

function buff:current()
    return self.value:sub(self.pos, self.pos + self.pos_len - 1), self.pos_len
end

function buff:peek()
    return self:character(self.pos + self.pos_len)
end

function buff:advance()
    local pos = self.pos + self.pos_len 
    self.pos = pos
    self.pos_char = self.value:sub(pos, pos)
    if     self.pos_char:match("[\000-\127]") then self.pos_len = 1
    elseif self.pos_char:match("[\192-\223]") then self.pos_len = 2
    elseif self.pos_char:match("[\224-\239]") then self.pos_len = 3
    elseif self.pos_char:match("[\240-\247]") then self.pos_len = 4
    elseif pos <= #self.value then
        error("invalid leading byte, please make sure your csv file is utf8 format")
    end
end

local function openbystring(content)
    content_buff, err = buff:new(content)
    if not content_buff then
        print(err)
    end


    local field_buff = {}
    local line_buff = {}
    local file_buff = {}
    local c = nil

    function add_current()
        table.insert(field_buff, c)
    end

    function  add_field()
        table.insert(line_buff, table.concat(field_buff))
        field_buff = {}
    end

    function  add_grid()
        table.insert(file_buff, line_buff)
        line_buff = {}
    end

    local is_in_quote = false
    while( content_buff.pos <= #content_buff.value) do
        c = content_buff:current()
        if c == char_quote then
            if not is_in_quote then
                is_in_quote = true
            else
                if content_buff:peek() == char_delimiter then
                    add_field()
                    content_buff:advance()
                    is_in_quote = false
                elseif content_buff:peek() == char_new_line or content_buff:peek() == char_carriage_return then
                    is_in_quote = false
                else
                    content_buff:advance() -- skip right double quote
                    add_current()
                end
            end
        elseif c == char_delimiter then
            if not is_in_quote then
                add_field()
            else
                add_current()
            end
        elseif c == char_new_line or c == char_carriage_return then
            if not is_in_quote then
                if c == char_carriage_return and content_buff:peek() == char_new_line then
                    content_buff:advance()
                end
                add_field()
                add_grid()
            else
                add_current()
            end
        else
            add_current()
        end
        content_buff:advance()
    end

    if #field_buff > 0 then
        add_field()
        add_grid()
    end
    return file_buff   
	
end

local function open(file)
    local file, err = io.open(file, "r")
    if not file then
        return nil, err
    end
    local content = file:read("*a")
    return openbystring(content)
end

return {open = openbystring}